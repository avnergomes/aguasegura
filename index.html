<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Água Segura — Mapa (filtros por camada/coluna)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root { --topbar-h: 44px; }
    html,body { height:100%; margin:0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; }
    #map { position:absolute; inset:var(--topbar-h) 0 0 0; }
    .topbar {
      position:fixed; left:0; right:0; top:0; height:var(--topbar-h);
      display:flex; align-items:center; gap:.5rem;
      background:#fff; border-bottom:1px solid #e5e7eb; padding:0 .75rem; z-index:1000;
    }
    .version{ margin-left:auto; color:#666; font-size:.85rem; white-space:nowrap }
    .btn{ border:1px solid #d1d5db; background:#fff; padding:.35rem .6rem; border-radius:8px; font-weight:600; cursor:pointer }
    .btn:hover{ background:#f9fafb }
    .leaflet-control-container { z-index: 500; }
    .leaflet-top.leaflet-right { margin-top: 10px; }
    .filter-box {
      background:#fff; padding:.6rem; border-radius:.75rem; border:1px solid #e5e7eb;
      box-shadow: 0 6px 18px rgba(0,0,0,.08); width: 320px; max-height: 70vh; overflow:auto;
      font-size: 13px;
    }
    .filter-box h3 { margin:.25rem 0 .5rem; font-size:14px; }
    .filter-box label { color:#6b7280; font-size:12px; display:block; margin-bottom:4px; }
    .filter-box select, .filter-box input[type="search"] {
      width:100%; padding:.45rem .5rem; border:1px solid #d1d5db; border-radius:.5rem; margin-bottom:.5rem;
      font-size:13px;
    }
    .row { display:flex; gap:.5rem; margin:.25rem 0 .5rem; }
    .btn-sm { padding:.3rem .5rem; border-radius:.5rem; border:1px solid #d1d5db; background:#fff; cursor:pointer; }
    .btn-sm.primary { background:#1d4ed8; color:#fff; border-color:#1d4ed8; }
    .list { border:1px solid #e5e7eb; border-radius:.5rem; max-height:28vh; overflow:auto; padding:.25rem; background:#fff; }
    .item { display:flex; align-items:center; gap:.5rem; padding:.25rem .35rem; border-radius:.35rem; }
    .item:hover { background:#f3f4f6; }
    .muted { color:#6b7280; font-size:12px; }
  </style>
</head>
<body>
  <div class="topbar">
    <button id="fitAll" class="btn">Ajustar visão</button>
    <div class="version">v2.2 — correção “ottos” + filtro com zoom</div>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>

  <script>
  // ====== CONFIG ======
  const BASE = "./data/";  // arquivos servidos em aguasegura/docs/data/

  // estilos por camada
  const styles = {
    declividade:        { color:'#8c510a', weight:1, fillColor:'#d8b365', fillOpacity:0.40 },
    altimetria:         { color:'#542788', weight:1, fillColor:'#b2abd2', fillOpacity:0.35 },
    uso_solo:           { color:'#006d2c', weight:1, fillColor:'#31a354', fillOpacity:0.35 },
    estradas:           { color:'#737373', weight:2, dashArray:'4,4', fillOpacity:0 },
    hidrografia:        { color:'#2b8cbe', weight:2, fillColor:'#67a9cf', fillOpacity:0.25 },
    nascentes:          { color:'#1c9099', weight:2, radius:5, fillColor:'#41b6c4', fillOpacity:0.80 },
    solos:              { color:'#a6611a', weight:1, fillColor:'#dfc27d', fillOpacity:0.45 },
    construcoes:        { color:'#252525', weight:1, radius:4, fillColor:'#636363', fillOpacity:0.90 },
    imoveiscar:         { color:'#d73027', weight:1, fillColor:'#fc8d59', fillOpacity:0.35 },
    caf:                { color:'#006837', weight:1, fillColor:'#31a354', fillOpacity:0.35 },
    otto_selec_lista4:  { color:'#1e40af', weight:2, fillColor:'#93c5fd', fillOpacity:0.25 }
  };

  // lista de camadas (corrigido: “ottos”)
  const LAYERS = [
    { name:'Declividade',  key:'declividade',  type:'poly',
      file:['declividade__declividade_otto.geojson.gz'] },
    { name:'Altimetria',   key:'altimetria',   type:'poly',
      file:['altimetria__altimetria_otto.geojson.gz'] },
    { name:'Uso do Solo',  key:'uso_solo',     type:'poly',
      file:['uso_solo__usodosolo_otto.geojson.gz'] },
    { name:'Estradas',     key:'estradas',     type:'line',
      file:['estradas__estradas_otto.geojson.gz'] },
    { name:'Hidrografia',  key:'hidrografia',  type:'line',
      file:['hidrografia__hidrografia_otto.geojson.gz'] },
    { name:'Nascentes',    key:'nascentes',    type:'point',
      file:['nascentes__nascentes_otto.geojson.gz'] },
    { name:'Solos',        key:'solos',        type:'poly',
      file:['solos__solos_otto.geojson.gz'] },
    { name:'Construções',  key:'construcoes',  type:'point',
      file:[
        'construcoes__construcoes_otto__part1.geojson.gz',
        'construcoes__construcoes_otto__part2.geojson.gz',
        'construcoes__construcoes_otto__part3.geojson.gz',
        'construcoes__construcoes_otto__part4.geojson.gz',
        'construcoes__construcoes_otto__part5.geojson.gz',
        'construcoes__construcoes_otto__part6.geojson.gz'
      ]},
    { name:'Seleção (otto_selec_lista4)', key:'otto_selec_lista4', type:'poly',
      file:['otto_selec__ottos_selec_lista4.geojson.gz'] },   // << aqui!
    { name:'CAF',          key:'caf',          type:'poly',
      file:['caf__caf_otto.geojson.gz'] }
  ];

  // ====== MAPA ======
  const baseStreets = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap • © CARTO', maxZoom: 20
  });
  const baseEsri = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Imagery: Esri/Maxar', maxZoom: 19
  });
  const map = L.map('map', { center: [-24.5,-51.5], zoom: 7, preferCanvas: true, layers:[baseStreets] });
  const layerControl = L.control.layers(
    { 'Streets': baseStreets, 'Satélite (Esri)': baseEsri },
    {}, { collapsed:false }
  ).addTo(map);

  // ====== ESTADO ======
  const addedLayers = [];
  const datasetByKey = {}; // key -> {def, features, layer}
  let currentKey = null;
  let currentProp = null;
  const activeValues = new Set();

  // ====== LOADER único (.geojson e .gz; suporta multi-arquivo) ======
  async function fetchMaybeGz(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    if (url.toLowerCase().endsWith(".gz")) {
      const ab = await res.arrayBuffer();
      const txt = window.pako.inflate(new Uint8Array(ab), { to: "string" });
      return JSON.parse(txt);
    }
    const ct = res.headers.get("content-type") || "";
    if (ct.includes("application/json")) return res.json();
    return JSON.parse(await res.text());
  }
  const toFeatArr = (gj) =>
    gj?.type === "FeatureCollection" ? (gj.features||[]) :
    (gj?.type === "Feature" ? [gj] : []);

  async function loadOne(def) {
    const files = Array.isArray(def.file) ? def.file : [def.file];
    const features = [];
    for (const f of files) {
      const url = BASE + f;
      try { features.push(...toFeatArr(await fetchMaybeGz(url))); }
      catch(e){ console.warn("Falha ao carregar", url, e); }
    }
    const st = styles[def.key] || { color:'#555', weight:2, fillOpacity:0.2 };
    const layer = L.geoJSON(features, {
      style: st,
      pointToLayer: (feat, latlng) => {
        if (def.type === 'point') {
          const s = styles[def.key] || {};
          return L.circleMarker(latlng, {
            radius: s.radius ?? 4,
            color:  s.color  ?? '#333',
            fillColor: s.fillColor ?? s.color ?? '#333',
            fillOpacity: s.fillOpacity ?? 0.8,
            weight: s.weight ?? 1
          });
        }
        return L.marker(latlng);
      },
      onEachFeature: (f,l) => {
        const p = f?.properties || {};
        const html = Object.keys(p).slice(0,20).map(k => `<div><b>${k}</b>: ${String(p[k])}</div>`).join('');
        if (html) l.bindPopup(html);
      }
    }).addTo(map);

    layerControl.addOverlay(layer, def.name);
    addedLayers.push(layer);
    datasetByKey[def.key] = { def, features, layer };
  }

  async function loadAll() { for (const def of LAYERS) await loadOne(def); }

  // ====== FIT visíveis
  document.getElementById('fitAll').onclick = () => {
    const visibles = addedLayers.filter(l => map.hasLayer(l));
    if(!visibles.length) return;
    const group = L.featureGroup(visibles);
    map.fitBounds(group.getBounds().pad(0.08));
  };

  // ====== CONTROLE DE FILTRO (camada + coluna texto + distinct + zoom) ======
  const FilterControl = L.Control.extend({
    onAdd: function() {
      const div = L.DomUtil.create('div','filter-box');
      div.innerHTML = `
        <h3>Filtros</h3>
        <label>Camada</label>
        <select id="fc-layer"></select>
        <label>Coluna (texto)</label>
        <select id="fc-prop"></select>
        <input id="fc-search" type="search" placeholder="Pesquisar valor..."/>
        <div class="row">
          <button id="fc-all" class="btn-sm">Marcar todos</button>
          <button id="fc-none" class="btn-sm">Desmarcar</button>
          <button id="fc-apply" class="btn-sm primary">Aplicar</button>
        </div>
        <div id="fc-list" class="list"></div>
        <div class="muted" style="margin-top:.4rem;">Apenas colunas com valores de texto aparecem.</div>
      `;
      L.DomEvent.disableClickPropagation(div);
      L.DomEvent.disableScrollPropagation(div);

      const selLayer = div.querySelector('#fc-layer');
      const selProp  = div.querySelector('#fc-prop');
      const search   = div.querySelector('#fc-search');
      const btnAll   = div.querySelector('#fc-all');
      const btnNone  = div.querySelector('#fc-none');
      const btnApply = div.querySelector('#fc-apply');
      const list     = div.querySelector('#fc-list');

      function refreshLayerOptions(){
        selLayer.innerHTML = '';
        Object.keys(datasetByKey).forEach(key => {
          const opt = document.createElement('option');
          opt.value = key; opt.textContent = datasetByKey[key].def.name;
          selLayer.appendChild(opt);
        });
        // prioriza a camada de seleção se existir
        currentKey = datasetByKey['otto_selec_lista4'] ? 'otto_selec_lista4'
                  : (currentKey && datasetByKey[currentKey] ? currentKey
                    : Object.keys(datasetByKey)[0]);
        selLayer.value = currentKey;
      }

      function textPropsFor(key){
        const ds = datasetByKey[key]; if(!ds) return [];
        const sample = (ds.features||[]).slice(0,200);
        const hits = {};
        for (const f of sample){
          const p = f.properties || {};
          for (const [k,v] of Object.entries(p)) {
            if (typeof v === 'string' && v !== '') hits[k] = (hits[k]||0) + 1;
          }
        }
        return Object.keys(hits).sort((a,b)=>a.localeCompare(b,'pt-BR'));
      }

      function refreshPropOptions(){
        selProp.innerHTML = '';
        const props = textPropsFor(currentKey);
        if (!props.length){
          selProp.innerHTML = `<option value="">(sem colunas de texto)</option>`;
          currentProp = null;
        } else {
          props.forEach(p => selProp.append(new Option(p,p)));
          // tenta escolher "Manancial" se existir
          currentProp = props.includes('Manancial') ? 'Manancial'
                     : (props.includes(currentProp) ? currentProp : props[0]);
          selProp.value = currentProp || '';
        }
      }

      function rebuildDistinctList(){
        list.innerHTML = ''; activeValues.clear();
        const ds = datasetByKey[currentKey]; if(!ds || !currentProp) return;
        const setVals = new Set();
        for (const f of ds.features) {
          const v = (f.properties||{})[currentProp];
          if (typeof v === 'string' && v !== '') setVals.add(v);
        }
        const values = Array.from(setVals).sort((a,b)=>a.localeCompare(b,'pt-BR'));
        const q = (search.value||'').toLowerCase().trim();
        const filtered = q ? values.filter(v => v.toLowerCase().includes(q)) : values;

        for (const val of filtered){
          const id = 'v_' + btoa(val).replace(/=/g,'');
          const row = document.createElement('label'); row.className='item'; row.htmlFor=id;
          const cb = Object.assign(document.createElement('input'), { type:'checkbox', id, value:val, checked:true });
          cb.addEventListener('change', e => (e.target.checked ? activeValues.add(val) : activeValues.delete(val)));
          const span = document.createElement('span'); span.textContent = val;
          row.append(cb, span); list.appendChild(row); activeValues.add(val);
        }
        if (!values.length) list.innerHTML = '<div class="muted">Sem valores distintos nesta coluna.</div>';
      }

      function applyFilter(){
        const ds = datasetByKey[currentKey]; if(!ds) return;
        if (ds.layer) { try{ map.removeLayer(ds.layer) }catch{}; try{ layerControl.removeLayer(ds.layer) }catch{}; ds.layer = null; }
        const st = styles[currentKey] || { color:'#555', weight:2, fillOpacity:0.2 };
        const feats = (!currentProp || !activeValues.size)
          ? []
          : ds.features.filter(f => typeof (f.properties||{})[currentProp] === 'string'
                                 && activeValues.has((f.properties||{})[currentProp]));
        const layer = L.geoJSON(feats, {
          style: st,
          pointToLayer: (feat, latlng) => {
            const s = styles[currentKey] || {};
            if (datasetByKey[currentKey].def.type === 'point') {
              return L.circleMarker(latlng, {
                radius: s.radius ?? 4,
                color:  s.color  ?? '#333',
                fillColor: s.fillColor ?? s.color ?? '#333',
                fillOpacity: s.fillOpacity ?? 0.8,
                weight: s.weight ?? 1
              });
            }
            return L.marker(latlng);
          },
          onEachFeature: (f,l) => {
            const p = f?.properties || {};
            const html = Object.keys(p).slice(0,20).map(k => `<div><b>${k}</b>: ${String(p[k])}</div>`).join('');
            if (html) l.bindPopup(html);
          }
        }).addTo(map);
        ds.layer = layer;
        layerControl.addOverlay(layer, datasetByKey[currentKey].def.name + " (filtrado)");

        // ZOOM automático ao resultado filtrado
        try {
          const b = layer.getBounds();
          if (b && b.isValid()) map.fitBounds(b.pad(0.10));
        } catch(e) {}
      }

      selLayer.addEventListener('change', ()=>{ currentKey = selLayer.value; refreshPropOptions(); rebuildDistinctList(); });
      selProp.addEventListener('change',  ()=>{ currentProp = selProp.value || null; rebuildDistinctList(); });
      search.addEventListener('input',    rebuildDistinctList);
      btnAll.addEventListener('click',    ()=>{ list.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = true; activeValues.add(cb.value); }); });
      btnNone.addEventListener('click',   ()=>{ list.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = false; activeValues.delete(cb.value); }); });
      btnApply.addEventListener('click',  applyFilter);

      setTimeout(()=>{ refreshLayerOptions(); refreshPropOptions(); rebuildDistinctList(); }, 60);
      return div;
    }
  });
  map.addControl(new FilterControl({ position: 'topright' }));

  (async function(){
    await loadAll();
    map.attributionControl.setPrefix(false);
    map.attributionControl.addAttribution('Água Segura • filtros por camada/coluna');
  })();
  </script>
</body>
</html>
