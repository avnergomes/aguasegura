<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Água Segura — mapa (classes + filtro Microbacias)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    :root { --topbar-h: 48px; }
    html,body { height:100%; margin:0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; }
    #map { position:absolute; inset:var(--topbar-h) 0 0 0; }
    .topbar {
      position:fixed; inset:0 0 auto 0; height:var(--topbar-h);
      display:flex; align-items:center; gap:.5rem;
      background:#fff; border-bottom:1px solid #e5e7eb; padding:0 .75rem; z-index:1000;
    }
    .btn{ border:1px solid #d1d5db; background:#fff; padding:.35rem .6rem; border-radius:8px; font-weight:600; cursor:pointer }
    .btn:hover{ background:#f9fafb }
    .version{ margin-left:auto; color:#666; font-size:.85rem; white-space:nowrap }

    .panel {
      background:#fff; padding:.6rem; border-radius:.75rem; border:1px solid #e5e7eb;
      box-shadow: 0 6px 18px rgba(0,0,0,.08); width: 320px; max-height: 70vh; overflow:auto;
      font-size: 13px;
    }
    .panel h3 { margin:.25rem 0 .5rem; font-size:14px; }
    .panel label { color:#6b7280; font-size:12px; display:block; margin:.35rem 0 .25rem; }
    .panel input[type="search"], .panel select {
      width:100%; padding:.45rem .5rem; border:1px solid #d1d5db; border-radius:.5rem;
    }
    .row { display:flex; gap:.5rem; margin:.4rem 0; }
    .btn-sm { padding:.3rem .5rem; border-radius:.5rem; border:1px solid #d1d5db; background:#fff; cursor:pointer; }
    .btn-sm.primary { background:#1d4ed8; color:#fff; border-color:#1d4ed8; }

    .list { border:1px solid #e5e7eb; border-radius:.5rem; max-height:28vh; overflow:auto; padding:.25rem; background:#fff; }
    .item { display:flex; align-items:center; gap:.5rem; padding:.25rem .35rem; border-radius:.35rem; }
    .item:hover { background:#f3f4f6; }

    .legend {
      background:#fff; border:1px solid #e5e7eb; border-radius:.75rem; padding:.5rem .6rem;
      font-size:12px; box-shadow: 0 6px 18px rgba(0,0,0,.08);
    }
    .leg-row { display:flex; align-items:center; gap:.5rem; margin:.15rem 0; }
    .sw { width:16px; height:12px; border:1px solid #9ca3af; border-radius:3px; }
  </style>
</head>
<body>
  <div class="topbar">
    <button id="fitAll" class="btn">Ajustar visão</button>
    <div class="version">v3 — classes + filtro Microbacias (Cod_man)</div>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>

  <script>
  // ====== CONFIG ======
  const BASE = "./data/";  // arquivos servidos em aguasegura/docs/data/

  // ====== CAMPOS (por camada) — ajuste se necessário ======
  const FIELDS = {
    declividade: ['classe','Classe','DECLIVID','DECLIV','SLOPE_CL','SLOPE'],  // %, texto ou num.
    solos:       ['classe','Classe','SOLO','SOIL','TIPO','CLASSE_SO'],
    altimetria:  ['alt','ALT','ALTITUDE','ALTIMETR','COTA'],                  // numérico
    uso_solo:    ['classe','Classe','USO','USO_DO_SO','CATEG','CLASSE_USO'],
  };

  // ====== LAYERS (nomes exatos dos arquivos .geojson.gz) ======
  const LAYERS = [
    { name:'Declividade',  key:'declividade',  type:'poly',
      file:['declividade__declividade_otto.geojson.gz'] },

    { name:'Altimetria',   key:'altimetria',   type:'poly',
      file:['altimetria__altimetria_otto.geojson.gz'] },

    { name:'Uso do Solo',  key:'uso_solo',     type:'poly',
      file:['uso_solo__usodosolo_otto.geojson.gz'] },

    { name:'Estradas',     key:'estradas',     type:'line',
      file:['estradas__estradas_otto.geojson.gz'] },

    { name:'Hidrografia',  key:'hidrografia',  type:'line',
      file:['hidrografia__hidrografia_otto.geojson.gz'] },

    { name:'Nascentes',    key:'nascentes',    type:'point',
      file:['nascentes__nascentes_otto.geojson.gz'] },

    { name:'Solos',        key:'solos',        type:'poly',
      file:['solos__solos_otto.geojson.gz'] },

    { name:'Construções',  key:'construcoes',  type:'point',
      file:[
        'construcoes__construcoes_otto__part1.geojson.gz',
        'construcoes__construcoes_otto__part2.geojson.gz',
        'construcoes__construcoes_otto__part3.geojson.gz',
        'construcoes__construcoes_otto__part4.geojson.gz',
        'construcoes__construcoes_otto__part5.geojson.gz',
        'construcoes__construcoes_otto__part6.geojson.gz'
      ]},

    // << renomeada para Microbacias (antes "otto_selec_lista4")
    { name:'Microbacias', key:'microbacias', type:'poly',
      file:['otto_selec__ottos_selec_lista4.geojson.gz'] },

    { name:'CAF',          key:'caf',          type:'poly',
      file:['caf__caf_otto.geojson.gz'] }
  ];

  // ====== PALETAS / SIMBOLOGIA ======
  // Declividade (% ou texto)
  const slopeBreaks = [0, 3, 8, 20, 45, 1000];
  const slopeColors = ['#edf8e9','#c7e9c0','#7fcdbb','#41b6c4','#1d91c0']; // claro→escuro
  const slopeTextMap = {
    '0-3': slopeColors[0], '0 – 3': slopeColors[0], 'plana': slopeColors[0],
    '3-8': slopeColors[1], '3 – 8': slopeColors[1], 'suave': slopeColors[1],
    '8-20': slopeColors[2], '8 – 20': slopeColors[2], 'moderada': slopeColors[2],
    '20-45': slopeColors[3], '20 – 45': slopeColors[3], 'forte': slopeColors[3],
    '>45': slopeColors[4], '45+': slopeColors[4], 'muito forte': slopeColors[4]
  };

  // Solos (classes textuais comuns)
  const soilColors = {
    'LATOSSOLO':'#d95f0e','ARGISSOLO':'#fdae6b','NEOSSOLO':'#fee6ce',
    'NITOSSOLO':'#a6761d','CAMBISSOLO':'#e0c2a2','GLEISSOLO':'#74c476',
    'CHERNOSSOLO':'#9e9ac8','PLANOSSOLO':'#bdbdbd','ESPODOSSOLO':'#9ecae1'
  };

  // Altimetria (numérica, m) — quebras fixas
  const altBreaks = [0, 400, 800, 1200, 1600, 10000];
  const altColors = ['#ffffcc','#c2e699','#78c679','#31a354','#006837'];

  // Uso do solo
  const usoColors = {
    'AGRICULTURA':'#e6ab02','AGRICOLA':'#e6ab02','LAVOURA':'#e6ab02','CULTIVO':'#e6ab02',
    'FLORESTA':'#1b9e77','MATA':'#1b9e77','VEGETAÇÃO':'#1b9e77','VEGETACAO':'#1b9e77',
    'PASTAGEM':'#a6d854','PASTO':'#a6d854',
    'URBANO':'#7570b3','URBANA':'#7570b3','CONSTRUÍDA':'#7570b3','CONSTRUIDA':'#7570b3',
    'ÁGUA':'#67a9cf','AGUA':'#67a9cf','CORPOS D\'ÁGUA':'#67a9cf',
    'OUTROS':'#bdbdbd','OUTRO':'#bdbdbd'
  };

  // ====== MAPA ======
  const baseStreets = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap • © CARTO', maxZoom: 20
  });
  const baseEsri = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Imagery: Esri/Maxar', maxZoom: 19
  });
  const map = L.map('map', { center: [-24.5,-51.5], zoom: 7, preferCanvas: true, layers:[baseStreets] });
  const layerControl = L.control.layers({ 'Streets': baseStreets, 'Satélite (Esri)': baseEsri }, {}, { collapsed:false }).addTo(map);

  // ====== ESTADO ======
  const datasetByKey = {};   // key -> {def, features, layer}
  const addedLayers = [];

  // ====== AJUDANTES ======
  async function fetchMaybeGz(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    if (url.toLowerCase().endsWith(".gz")) {
      const ab = await res.arrayBuffer();
      return JSON.parse(window.pako.inflate(new Uint8Array(ab), { to: "string" }));
    }
    const ct = res.headers.get("content-type") || "";
    if (ct.includes("application/json")) return res.json();
    return JSON.parse(await res.text());
  }
  const toFeatArr = (gj) =>
    gj?.type === "FeatureCollection" ? (gj.features||[]) :
    (gj?.type === "Feature" ? [gj] : []);

  function findField(props, candidates){
    const keys = Object.keys(props||{});
    for (const c of candidates){
      if (keys.includes(c)) return c;
      const k = keys.find(k => k.toLowerCase() === c.toLowerCase());
      if (k) return k;
    }
    return null;
  }

  function colorForDeclividade(p){
    // tente texto
    const f = findField(p, FIELDS.declividade);
    if (!f) return '#7fcdbb';
    const v = p[f];
    if (typeof v === 'string'){
      const t = v.normalize('NFD').replace(/[\u0300-\u036f]/g,'').toLowerCase();
      const hit = Object.keys(slopeTextMap).find(k => t.includes(k.replace('–','-')));
      return hit ? slopeTextMap[hit] : '#7fcdbb';
    }
    const num = Number(v);
    if (!isNaN(num)){
      for (let i=0;i<slopeBreaks.length-1;i++){
        if (num >= slopeBreaks[i] && num < slopeBreaks[i+1]) return slopeColors[i];
      }
    }
    return '#7fcdbb';
  }

  function colorForAltimetria(p){
    const f = findField(p, FIELDS.altimetria);
    const num = Number(p[f]);
    if (isNaN(num)) return '#b2abd2';
    for (let i=0;i<altBreaks.length-1;i++){
      if (num >= altBreaks[i] && num < altBreaks[i+1]) return altColors[i];
    }
    return altColors[altColors.length-1];
  }

  function colorForSolos(p){
    const f = findField(p, FIELDS.solos);
    if (!f) return '#dfc27d';
    const t = String(p[f] ?? '').toUpperCase();
    const hit = Object.keys(soilColors).find(k => t.includes(k));
    return hit ? soilColors[hit] : '#dfc27d';
  }

  function colorForUso(p){
    const f = findField(p, FIELDS.uso_solo);
    if (!f) return '#31a354';
    const t = String(p[f] ?? '').toUpperCase();
    const hit = Object.keys(usoColors).find(k => t.includes(k));
    return hit ? usoColors[hit] : '#31a354';
  }

  function styleFn(key){
    // retorna uma função de estilo por camada (classificada quando aplicável)
    if (key === 'declividade') return (f)=>({ color:'#555', weight:0.5, fillColor: colorForDeclividade(f.properties), fillOpacity:0.65 });
    if (key === 'altimetria')  return (f)=>({ color:'#333', weight:0.4, fillColor: colorForAltimetria(f.properties),  fillOpacity:0.60 });
    if (key === 'solos')       return (f)=>({ color:'#555', weight:0.4, fillColor: colorForSolos(f.properties),       fillOpacity:0.65 });
    if (key === 'uso_solo')    return (f)=>({ color:'#444', weight:0.4, fillColor: colorForUso(f.properties),          fillOpacity:0.55 });
    // padrões
    const defaults = {
      estradas:   { color:'#737373', weight:2, dashArray:'4,4', fillOpacity:0 },
      hidrografia:{ color:'#2b8cbe', weight:2, fillOpacity:0.2 },
      nascentes:  { color:'#1c9099', weight:2, fillOpacity:0.8 },
      construcoes:{ color:'#252525', weight:1, fillOpacity:0.9 },
      caf:        { color:'#006837', weight:1, fillOpacity:0.35 },
      microbacias:{ color:'#1e40af', weight:2, fillColor:'#93c5fd', fillOpacity:0.25 }
    };
    return ()=> (defaults[key] || { color:'#555', weight:1, fillOpacity:0.25 });
  }

  function addLegend(id, title, items){
    const ctrl = L.control({position:'bottomleft'});
    ctrl.onAdd = function(){
      const div = L.DomUtil.create('div','legend');
      div.id = id;
      div.innerHTML = `<div><b>${title}</b></div>` + items.map(it=>(
        `<div class="leg-row"><span class="sw" style="background:${it[1]}"></span>${it[0]}</div>`
      )).join('');
      return div;
    };
    ctrl.addTo(map);
    return ctrl;
  }

  // Legendas (fixas) — ajuste textos conforme seu dado
  const legDecliv = addLegend('leg-decliv','Declividade (%)',[
    ['0–3', slopeColors[0]], ['3–8', slopeColors[1]], ['8–20', slopeColors[2]],
    ['20–45', slopeColors[3]], ['>45', slopeColors[4]]
  ]);
  const legAlt = addLegend('leg-alt','Altimetria (m)',[
    ['0–400', altColors[0]], ['400–800', altColors[1]], ['800–1200', altColors[2]],
    ['1200–1600', altColors[3]], ['>1600', altColors[4]]
  ]);
  const legUso = addLegend('leg-uso','Uso do Solo',[
    ['Agricultura', usoColors.AGRICULTURA], ['Floresta', usoColors.FLORESTA],
    ['Pastagem', usoColors.PASTAGEM], ['Urbano', usoColors.URBANO], ['Água', usoColors['ÁGUA']],
    ['Outros', usoColors.OUTROS]
  ]);
  const legSolos = addLegend('leg-solos','Solos (classes)', Object.entries(soilColors).map(([k,v])=>[k,v]));

  // ====== LOAD LAYERS ======
  async function loadOne(def) {
    const files = Array.isArray(def.file) ? def.file : [def.file];
    const features = [];
    for (const f of files) {
      const url = BASE + f;
      try { features.push(...toFeatArr(await fetchMaybeGz(url))); }
      catch(e){ console.warn("Falha ao carregar", url, e); }
    }
    const layer = L.geoJSON(features, {
      style: styleFn(def.key),
      pointToLayer: (feat, latlng) => {
        if (def.type === 'point') {
          return L.circleMarker(latlng, { radius: 4, color:'#333', weight:1, fillOpacity:0.8 });
        }
        return L.marker(latlng);
      },
      onEachFeature: (f,l) => {
        const p = f?.properties || {};
        const html = Object.keys(p).slice(0,20).map(k => `<div><b>${k}</b>: ${String(p[k])}</div>`).join('');
        if (html) l.bindPopup(html);
      }
    }).addTo(map);

    layerControl.addOverlay(layer, def.name);
    datasetByKey[def.key] = { def, features, layer };
    addedLayers.push(layer);
  }
  async function loadAll() { for (const def of LAYERS) await loadOne(def); }

  // Ajustar visão para visíveis
  document.getElementById('fitAll').onclick = () => {
    const visibles = addedLayers.filter(l => map.hasLayer(l));
    if(!visibles.length) return;
    const group = L.featureGroup(visibles);
    map.fitBounds(group.getBounds().pad(0.08));
  };

  // ====== FILTRO EXCLUSIVO — MICROBACIAS por Cod_man ======
  const MicroFilter = L.Control.extend({
    onAdd: function() {
      const div = L.DomUtil.create('div','panel');
      div.innerHTML = `
        <h3>Filtro — Microbacias</h3>
        <label>Cod_man</label>
        <input id="mf-search" type="search" placeholder="Pesquisar código..."/>
        <div class="row">
          <button id="mf-all" class="btn-sm">Marcar todos</button>
          <button id="mf-none" class="btn-sm">Desmarcar</button>
          <button id="mf-apply" class="btn-sm primary">Aplicar</button>
        </div>
        <div id="mf-list" class="list" aria-label="Códigos Cod_man"></div>
      `;
      L.DomEvent.disableClickPropagation(div);
      L.DomEvent.disableScrollPropagation(div);

      const list = div.querySelector('#mf-list');
      const search = div.querySelector('#mf-search');
      const btnAll = div.querySelector('#mf-all');
      const btnNone = div.querySelector('#mf-none');
      const btnApply = div.querySelector('#mf-apply');

      const ds = ()=> datasetByKey['microbacias'];
      const active = new Set();
      let allCodes = [];

      function buildList(){
        list.innerHTML = '';
        const d = ds(); if (!d) return;
        // detectar campo Cod_man (ou similar)
        const sample = d.features[0]?.properties || {};
        const codField = ['Cod_man','COD_MAN','cod_man','codman','cod','codigo']
          .map(n=>Object.keys(sample).find(k=>k.toLowerCase()===n.toLowerCase()))
          .find(Boolean) || 'Cod_man';

        const set = new Set();
        for (const f of d.features){
          const v = (f.properties||{})[codField];
          if (v !== undefined && v !== null && String(v)!=='') set.add(String(v));
        }
        allCodes = Array.from(set).sort((a,b)=>a.localeCompare(b,'pt-BR'));

        const q = (search.value||'').toLowerCase().trim();
        const filtered = q ? allCodes.filter(v => v.toLowerCase().includes(q)) : allCodes;

        for (const val of filtered){
          const id = 'cod_' + btoa(val).replace(/=/g,'');
          const row = document.createElement('label'); row.className='item'; row.htmlFor=id;
          const cb = Object.assign(document.createElement('input'), { type:'checkbox', id, value:val, checked:true });
          cb.addEventListener('change', e => (e.target.checked ? active.add(val) : active.delete(val)));
          const span = document.createElement('span'); span.textContent = val;
          row.append(cb, span); list.appendChild(row); active.add(val);
        }

        // guarda campo para apply
        list.dataset.codfield = codField;
      }

      function apply(){
        const d = ds(); if (!d) return;
        if (d.layer) { try{ map.removeLayer(d.layer) }catch{}; try{ layerControl.removeLayer(d.layer) }catch{}; d.layer = null; }
        const field = list.dataset.codfield || 'Cod_man';
        const feats = Array.from(active).length
          ? d.features.filter(f => String((f.properties||{})[field]) && active.has(String((f.properties||{})[field])))
          : [];
        const layer = L.geoJSON(feats, {
          style: styleFn('microbacias'),
          onEachFeature: (f,l) => {
            const p = f?.properties || {};
            const html = `<div><b>Cod_man</b>: ${String(p[field])}</div>` +
                         Object.keys(p).filter(k=>k!==field).slice(0,15).map(k=>`<div><b>${k}</b>: ${String(p[k])}</div>`).join('');
            if (html) l.bindPopup(html);
          }
        }).addTo(map);
        d.layer = layer;
        layerControl.addOverlay(layer, "Microbacias (filtrado)");

        try {
          const b = layer.getBounds();
          if (b && b.isValid()) map.fitBounds(b.pad(0.12));
        } catch(e) {}
      }

      search.addEventListener('input', buildList);
      btnAll.addEventListener('click', ()=>{ list.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = true; active.add(cb.value); }); });
      btnNone.addEventListener('click', ()=>{ list.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = false; active.delete(cb.value); }); });
      btnApply.addEventListener('click', apply);

      setTimeout(buildList, 400); // aguarda carregamento das camadas
      return div;
    }
  });
  map.addControl(new MicroFilter({ position: 'topright' }));

  // ====== BOOT ======
  (async function(){
    await loadAll();
    map.attributionControl.setPrefix(false);
    map.attributionControl.addAttribution('Água Segura • classes + filtro Microbacias');
  })();
  </script>
</body>
</html>
